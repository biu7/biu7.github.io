<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>biubiu7 - 逆向</title><link href="/" rel="alternate"></link><link href="/feeds/ni-xiang.atom.xml" rel="self"></link><id>/</id><updated>2019-11-06T00:00:00+08:00</updated><entry><title>逆向某疫苗预约 App 并成功帮女朋友抢到九价 HPV 疫苗</title><link href="/2019/11/06/hpv_reservation/" rel="alternate"></link><published>2019-11-06T00:00:00+08:00</published><updated>2019-11-06T00:00:00+08:00</updated><author><name>qi</name></author><id>tag:None,2019-11-06:/2019/11/06/hpv_reservation/</id><summary type="html">&lt;p&gt;逆向了某疫苗预约 App，写代码抢到 HPV 九价疫苗的故事&lt;/p&gt;</summary><content type="html">&lt;p&gt;注：迫于最近抓了好多搞爬虫的，因此以下不出现具体的省市名及 App 名称&lt;/p&gt;
&lt;p&gt;自 HPV 疫苗国内上市已经有一年多了，然而由于疫苗产能不足的原因，各地疫苗都是供不应求。打电话给上海各个接种点得到的回复都是已经排队到一年以后了 orz...&lt;/p&gt;
&lt;p&gt;无奈之下只好各种找疫苗代约，他们真的是坐地起价啊！预约费几乎都是两千元以上，有的甚至算上疫苗一共 8888 ？？？（此处有科普：一针疫苗 + 注射费 = 1326 元，三针约四千元），简直是抢钱。&lt;/p&gt;
&lt;p&gt;算起来女朋友还有一年半才到26岁，也并不是很急，毕竟 26.5 岁之前打第一针就可以。因此开始查找上海附近有哪些地方开放线上预约的，一番查找之后（几个月过去了。。。），发现 隔壁 XX 市是在 App 上进行预约的，嘿这不就到了我的老本行了吗，是时候展现真正的技术了！&lt;/p&gt;
&lt;p&gt;下载 App 后注册账号测试，软件看起来一股外包味，本来以为怕是没加密没加固轻松搞定，没想到抓包发现加密了：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://img.biubiu7.cn/blog/201911060001.jpeg"&gt;&lt;/p&gt;
&lt;p&gt;没办法，只能尝试逆向或者 Hook 看看了。&lt;/p&gt;
&lt;p&gt;逆向是有点麻烦的，所以我们先用 Frida 找一下有没有明显是加密方法的函数，有的话就省事儿了。这里介绍一个工具：Brida，他是 Brup Suite 的一个插件，需要配合 Frida 使用，效果极佳。&lt;/p&gt;
&lt;p&gt;打开 Brup Suite 和 Brida ，启动 Frida Server 然后一通操作，我们就得到了 App 的类列表，根据包名筛选一下，果然发现一个极其明显的类名：com.xxxx.xxx.utils.SecretKeyUtil，果断 Hook 掉，在 Brida 控制台会打印出类中的方法并逐个 Hook ：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://img.biubiu7.cn/blog/201911060002.png"&gt;&lt;/p&gt;
&lt;p&gt;通过这些方法名我们也能看出这个类是 AES 加密的实现类，考虑到 Java 中 AES 加密是有标准库的实现的，因此 App 使用的密钥及加密模式很有可能可以直接从这个类中找到。在 App 中做一些操作，尝试触发这个类的方法，结果如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://img.biubiu7.cn/blog/201911060003.jpeg"&gt;
&lt;img alt="" src="https://img.biubiu7.cn/blog/201911060004.jpeg"&gt;&lt;/p&gt;
&lt;p&gt;上图中得到两个疑似加密 key 的字符串，另外还得到了加密前的原始字符串和加密结果。虽然没有得到加密模式及 AES 使用的偏移量，但也足够我们测试出具体的加密方式了。&lt;/p&gt;
&lt;p&gt;测试加密方法的过程略过不谈。事实上对于加密方法的 Hook ，我们还可以直接 Hook Java 标准库的加密方法，以直接得到加密所需的参数。在抓包中可以看到，其实除了加密过的参数之外，还有一个疑似 MD5 处理的 sign 参数，这个参数就可以使用 Hook Java 标准库中的 MD5 方法，来得到 MD5 前的具体参数值，这个就不详细描述了，过程与上述过程类似。&lt;/p&gt;</content><category term="逆向"></category></entry><entry><title>Magisk 导致 ro.debuggable 修改无效的排查处理</title><link href="/2019/05/14/Magisk-Hide-debuggable/" rel="alternate"></link><published>2019-05-14T13:00:00+08:00</published><updated>2019-05-14T13:00:00+08:00</updated><author><name>qi</name></author><id>tag:None,2019-05-14:/2019/05/14/Magisk-Hide-debuggable/</id><summary type="html">&lt;p&gt;做逆向时免不了几个操作：设置 ro.debuggable=1、root、xposed 。在 supersu 被国内公司收购之后， Magisk 成了 Android 设备 root 的第一选择。但是今天发现 magisk 的安装竟然会导致 ro.debuggable=1 的设置失效？&lt;/p&gt;</summary><content type="html">&lt;h4&gt;简介&lt;/h4&gt;
&lt;p&gt;做逆向时免不了几个操作：设置 ro.debuggable=1、root、xposed 。在 supersu 被国内公司收购之后， Magisk 成了 Android 设备 root 的第一选择。但是今天发现 magisk 的安装竟然会导致 ro.debuggable=1 的设置失效？&lt;/p&gt;
&lt;h4&gt;前情&lt;/h4&gt;
&lt;p&gt;之前一直使用正常的测试机 nexus 5，由于被同事借来借去，搞得手机里一团糟，因此打算直接重新刷机，还它一片碧水蓝天。nexus 5 刷机及逆向所需配置见 [此处还没写哈哈哈哈]，此处略过。&lt;/p&gt;
&lt;p&gt;在之前，我是使用 xposed 的模块 &lt;a href="https://github.com/riusksk/BDOpener"&gt;BDOpener&lt;/a&gt; 来直接开启调试，而非手动修改 ro.debuggable 的值，但是本次我打算直接改掉它，一劳永逸：&lt;a href="https://bbs.pediy.com/thread-197334.htm"&gt;修改Nexus5的boot.img - 打开系统调试   &lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在修改完 ro.debuggable=1 并重新刷入 boot.img 之后，顺手装上了 Magisk 作为 root 管理，并准备直接使用 magisk 安装 systemless 版的 xposed 框架来使用。全部装完之后，插上电脑准备看看 ro.debuggable 的修改生效了没，adb shell 进入 Android shell，getprop ro.debuggable 获取一下值，如下图：
&lt;img alt="图片1" src="https://img-1251994035.cos.ap-shanghai.myqcloud.com/blog/201905140001.png"&gt;
似乎没生效？？？&lt;/p&gt;
&lt;h4&gt;问题排查&lt;/h4&gt;
&lt;p&gt;查看 default.prop 文件中 ro.debuggable 的配置：
&lt;img alt="图片2" src="https://img-1251994035.cos.ap-shanghai.myqcloud.com/blog/201905140002.png"&gt;
配置似乎没有问题，说明之前的 boot.img 的修改是生效的。那么结合到 Magisk 的主要功能，这个大概就是 Magisk 的锅了。尝试完全卸载 Magisk 之后再查看 ro.dubuggable 的值，果然就是 1 了。&lt;/p&gt;
&lt;p&gt;google 了一下，发现 MagiskHide 确实会修改 ro.debuggable 等参数的值来使手机更容易通过安全检查：&lt;a href="https://github.com/Magisk-Modules-Repo/MagiskHidePropsConf#setreset-magiskhide-sensitive-props"&gt;此处是文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注：部分应用会检测手机是否 root、是否安装了 Magisk 、xposed 等框架、甚至是否打开了 usb 调试，比如交通银行买单吧检测 root 退出、中国移动检测 root 和 xposed 闪退或卡启动页、微信检测 xposed 封号等，MagiskHide 能够一定程度上隐藏手机的 root 及 Magisk 安装情况。&lt;/p&gt;
&lt;h4&gt;解决&lt;/h4&gt;
&lt;p&gt;既然知道了原因，自然有办法解决。Magisk 自身提供了 Resetprop 方法来修改系统属性值，不过经测试似乎不能持久化修改，即重启后修改后的值会恢复，我们使用 Magisk 模块 &lt;a href="https://forum.xda-developers.com/apps/magisk/module-magiskhide-props-config-t3789228"&gt;MagiskHide Props Config&lt;/a&gt;来修改就好。&lt;/p&gt;
&lt;p&gt;在 Magisk 自带的下载中搜索，然后安装、重启。重启后 adb shell 进入 shell，输入 props 回车，输入 4 选择 Edit MagiskHide props，然后选择修改 ro.debuggable ，之后按照提示一路 y 过去，重启后再查看 ro.debuggable ,已经 ok 了，电脑打开 DDMS 查看，也能够看到手机上的进程，完事儿。&lt;/p&gt;</content><category term="逆向"></category><category term="逆向"></category><category term="爬虫"></category></entry></feed>